

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Building a Pipeline of Request Handlers &mdash; Paramore 7.0.0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Passing information between Handlers in the Pipeline" href="UsingTheContextBag.html" />
    <link rel="prev" title="Dispatching Requests" href="DispatchingARequest.html" /> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> Paramore
          

          
          </a>

          
            
            
              <div class="version">
                7.0.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="ImplementingAHandler.html">How to Implement a Request Handler</a></li>
<li class="toctree-l1"><a class="reference internal" href="DispatchingARequest.html">Dispatching Requests</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Building a Pipeline of Request Handlers</a></li>
<li class="toctree-l1"><a class="reference internal" href="#the-pipes-and-filters-architectural-style">The Pipes and Filters Architectural Style</a></li>
<li class="toctree-l1"><a class="reference internal" href="#the-russian-doll-model">The Russian Doll Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="#implementing-a-pipeline">Implementing a Pipeline</a></li>
<li class="toctree-l1"><a class="reference internal" href="#using-a-manual-approach">Using a Manual Approach</a></li>
<li class="toctree-l1"><a class="reference internal" href="UsingTheContextBag.html">Passing information between Handlers in the Pipeline</a></li>
<li class="toctree-l1"><a class="reference internal" href="PolicyRetryAndCircuitBreaker.html">Supporting Retry and Circuit Breaker</a></li>
<li class="toctree-l1"><a class="reference internal" href="PolicyRetryAndCircuitBreaker.html#using-brighter-s-usepolicy-attribute">Using Brighter’s UsePolicy Attribute</a></li>
<li class="toctree-l1"><a class="reference internal" href="PolicyRetryAndCircuitBreaker.html#timeout">Timeout</a></li>
<li class="toctree-l1"><a class="reference internal" href="PolicyFallback.html">Failure and Fallback</a></li>
<li class="toctree-l1"><a class="reference internal" href="EventSourcing.html">Event Sourcing</a></li>
<li class="toctree-l1"><a class="reference internal" href="EventSourcing.html#command-or-event-sourcing">Command or Event Sourcing</a></li>
<li class="toctree-l1"><a class="reference internal" href="EventSourcing.html#command-sourcing-in-brighter">Command Sourcing in Brighter</a></li>
<li class="toctree-l1"><a class="reference internal" href="BasicConfiguration.html">Basic Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="BasicConfiguration.html#what-you-need-to-provide">What you need to provide</a></li>
<li class="toctree-l1"><a class="reference internal" href="Logging.html">Supporting Logging</a></li>
<li class="toctree-l1"><a class="reference internal" href="ImplementingDistributedTaskQueue.html">Implementing a Distributed Task Queue</a></li>
<li class="toctree-l1"><a class="reference internal" href="ImplementingDistributedTaskQueue.html#brighter-s-task-queue-architecture">Brighter’s Task Queue Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="ImplementingDistributedTaskQueue.html#do-i-have-to-use-a-broker-what-about-msmq">Do I have to use a Broker, what about MSMQ?</a></li>
<li class="toctree-l1"><a class="reference internal" href="ImplementingDistributedTaskQueue.html#what-happens-when-the-consumer-receives-the-message">What happens when the consumer receives the message?</a></li>
<li class="toctree-l1"><a class="reference internal" href="ImplementingDistributedTaskQueue.html#what-does-this-look-like-in-code">What does this look like in code</a></li>
<li class="toctree-l1"><a class="reference internal" href="ImplementingDistributedTaskQueue.html#the-dispatcher">The Dispatcher</a></li>
<li class="toctree-l1"><a class="reference internal" href="ImplementingDistributedTaskQueue.html#configuration">Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="Routing.html">Routing</a></li>
<li class="toctree-l1"><a class="reference internal" href="DistributedTaskQueueConfiguration.html">Distributed Task Queue Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="DistributedTaskQueueConfiguration.html#configuring-the-dispatcher-in-code">Configuring the Dispatcher in Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="RabbitMQConfiguration.html">RabbitMQ Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="RunningUnderAWSSQSInfrastructure.html">Running Brighter under AWS SQS Infrastructure</a></li>
<li class="toctree-l1"><a class="reference internal" href="AWSSQSConfiguration.html">AWS SQS Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="AsyncDispatchARequest.html">Dispatching Requests Asynchronously</a></li>
<li class="toctree-l1"><a class="reference internal" href="ImplementingAsyncHandler.html">How to Implement an Asynchronous Request Handler</a></li>
<li class="toctree-l1"><a class="reference internal" href="BuildingAnAsyncPipeline.html">Building a Pipeline of Async Request Handlers</a></li>
<li class="toctree-l1"><a class="reference internal" href="BuildingAnAsyncPipeline.html#implementing-a-pipeline">Implementing a Pipeline</a></li>
<li class="toctree-l1"><a class="reference internal" href="Monitoring.html">Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="FeatureSwitches.html">Feature Switches</a></li>
<li class="toctree-l1"><a class="reference internal" href="faq.html">Frquently Asked Questions</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Paramore</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Building a Pipeline of Request Handlers</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/BuildingAPipeline.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="building-a-pipeline-of-request-handlers">
<h1>Building a Pipeline of Request Handlers<a class="headerlink" href="#building-a-pipeline-of-request-handlers" title="Permalink to this headline">¶</a></h1>
<p>Once you are using the features of Brighter to act as a <a class="reference external" href="https://brightercommand.github.io/Brighter/CommandsCommandDispatcherandProcessor.html">command
dispatcher</a> and send or // failing link
publish messages to a target handler, you may want to use its <a class="reference external" href="https://brightercommand.github.io/Brighter/CommandsCommandDispatcherandProcessor.html">command
processor</a> features to // failing link
handle orthogonal operations.</p>
<p>Common examples of orthogonal operations include:</p>
<ul class="simple">
<li>Logging the Command</li>
<li>Providing integration with tools for monitoring performance and
availability</li>
<li>Validating the Command</li>
<li>Supporting idempotency of messages</li>
<li>Supporting re-sequencing of messages</li>
<li>Handling exceptions</li>
<li><a class="reference external" href="QualityOfServicePatterns.html">Providing Timeout, Retry, and Circuit Breaker
support</a> // failing link</li>
<li>Providing undo support, or rollback</li>
</ul>
</div>
<div class="section" id="the-pipes-and-filters-architectural-style">
<h1>The Pipes and Filters Architectural Style<a class="headerlink" href="#the-pipes-and-filters-architectural-style" title="Permalink to this headline">¶</a></h1>
<p>To handle these orthogonal concerns our <a class="reference external" href="https://brightercommand.github.io/Brighter/CommandsCommandDispatcherandProcessor.html">command
processor</a> uses a pipes // failing link
and filters architectural style: the filters are where processing
occurs, they do not share state with other filters, nor do they know
about adjacent filters. The pipe is the connector between the filters in
our case this is provided by the <strong>IHandleRequests&lt;TRequest&gt;</strong> interface
which has a method <strong>IHandleRequests&lt;TRequest&gt; Successor</strong> that allows
us to chain filters together.</p>
<p><img alt="PipesAndFilters" src="_images/PipesAndFilters.png" /></p>
<p>The sink handler is handler that is the receiver you wish to invoke the
action on. The pump is the <strong>Command Dispatcher</strong>. We occasionally use
<em>target handler</em> as a synonym for <em>sink handler</em></p>
</div>
<div class="section" id="the-russian-doll-model">
<h1>The Russian Doll Model<a class="headerlink" href="#the-russian-doll-model" title="Permalink to this headline">¶</a></h1>
<p>Our pipes and filters approach supports the <em>Russian Doll Model</em> of
calling the handler pipeline, a context bag for the pipeline, and
support for generating a request path description out-of-the-box.</p>
<p>The <em>Russian Doll Model</em> is names for the
<a class="reference external" href="https://en.wikipedia.org/wiki/Matryoshka_doll">Matryoshka</a> wooden
dolls, in which dolls of decreasing sizes are nested one inside another.
The importance of this for a <a class="reference external" href="https://msdn.microsoft.com/en-us/library/dn589788.aspx">pipes and filters
pattern</a>
style is that each filter in the pipeline is called within the scope of
a previous filter in the pipeline.</p>
<p><img alt="RussianDoll" src="_images/RussianDoll.png" /></p>
<p>This is significant because you may desire to act before and after a
subsequent filter step. One particular use case is exception handling: a
try-catch block that wraps the call to a subsequent step can react to
exceptions raised by subsequent steps. This allows us to create policy
decisions around exceptions using a library such as
<a class="reference external" href="https://github.com/App-vNext/Polly">Polly</a> and thus support
<a class="reference external" href="https://msdn.microsoft.com/en-us/library/dn589788.aspx">Retry</a> and
<a class="reference external" href="https://msdn.microsoft.com/en-gb/library/dn589784.aspx?f=255&amp;MSPPError=-2147217396">Circuit
Breaker</a></p>
<p>Our usage of the Russian Doll Model was inspired by
<a class="reference external" href="http://codebetter.com/jeremymiller/2011/01/09/fubumvcs-internal-runtime-the-russian-doll-model-and-how-it-compares-to-asp-net-mvc-and-openrasta/">FubuMVC</a></p>
</div>
<div class="section" id="implementing-a-pipeline">
<h1>Implementing a Pipeline<a class="headerlink" href="#implementing-a-pipeline" title="Permalink to this headline">¶</a></h1>
<p>The first step in building a pipeline is to decide that we want an
orthogonal operation in our pipeline. Let us assume that we want to do
basic request logging.</p>
<p>Because you do not want to write an orthogonal handler for every Command
or Event type, these handlers should remain generic types. At runtime the
HandlerFactory creates an instance of the generic type specialized for the
type parameter of the Command or Event being passed along the pipeline.</p>
<p>The limitation here is that you can only make assumptions about the type
you receive into the pipeline from the constraints on the generic type.</p>
<p>Although it is possible to implement the
<a class="reference external" href="https://github.com/BrighterCommand/Brighter/blob/master/src/Paramore.Brighter/IHandleRequests.cs">IHandleRequests</a>
interface directly, we recommend deriving your handler from
<a class="reference external" href="https://github.com/BrighterCommand/Brighter/blob/master/src/Paramore.Brighter/RequestHandler.cs">RequestHandler&lt;T&gt;</a>.</p>
<p>Let us assume that we want to log all requests travelling through the
pipeline. (We provide this for you in the
Brighter.CommandProcessor packages so this for illustration
only). We could implement a generic handler as follows:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">Newtonsoft.Json</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">Brighter.commandprocessor.Logging</span><span class="p">;</span>

<span class="k">namespace</span> <span class="nn">Brighter.commandprocessor</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">class</span> <span class="nc">RequestLoggingHandler</span><span class="p">&lt;</span><span class="n">TRequest</span><span class="p">&gt;</span>
        <span class="p">:</span> <span class="n">RequestHandler</span><span class="p">&lt;</span><span class="n">TRequest</span><span class="p">&gt;</span> <span class="k">where</span> <span class="n">TRequest</span> <span class="p">:</span> <span class="n">class</span><span class="p">,</span> <span class="n">IRequest</span>
    <span class="p">{</span>
        <span class="k">private</span> <span class="n">HandlerTiming</span> <span class="n">_timing</span><span class="p">;</span>

        <span class="k">public</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">InitializeFromAttributeParams</span><span class="p">(</span>
            <span class="k">params</span> <span class="kt">object</span><span class="p">[]</span> <span class="n">initializerList</span>
        <span class="p">)</span>
        <span class="p">{</span>
            <span class="n">_timing</span> <span class="p">=</span> <span class="p">(</span><span class="n">HandlerTiming</span><span class="p">)</span><span class="n">initializerList</span><span class="p">[</span><span class="m">0</span><span class="p">];</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="k">override</span> <span class="n">TRequest</span> <span class="nf">Handle</span><span class="p">(</span><span class="n">TRequest</span> <span class="n">command</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">LogCommand</span><span class="p">(</span><span class="n">command</span><span class="p">);</span>
            <span class="k">return</span> <span class="k">base</span><span class="p">.</span><span class="n">Handle</span><span class="p">(</span><span class="n">command</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">private</span> <span class="k">void</span> <span class="nf">LogCommand</span><span class="p">(</span><span class="n">TRequest</span> <span class="n">request</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">logger</span><span class="p">.</span><span class="n">InfoFormat</span><span class="p">(</span><span class="s">&quot;Logging handler pipeline call. Pipeline timing {0} target, for {1} with values of {2} at: {3}&quot;</span><span class="p">,</span>
                <span class="n">_timing</span><span class="p">.</span><span class="n">ToString</span><span class="p">(),</span>
                <span class="k">typeof</span><span class="p">(</span><span class="n">TRequest</span><span class="p">),</span>
                <span class="n">JsonConvert</span><span class="p">.</span><span class="n">SerializeObject</span><span class="p">(</span><span class="n">request</span><span class="p">),</span>
                <span class="n">DateTime</span><span class="p">.</span><span class="n">UtcNow</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Our Handle method is the method which will be called by the pipeline to
service the request. After we log we call <strong>return
base.Handle(command)</strong> to ensure that the next handler in the chain is
called. If we failed to do this, the <em>target handler</em> would not be
called nor any subsequent handlers in the chain. This call to the next
item in the chain is how we support the ‘Russian Doll’ model - because
the next handler is called within the scope of this handler, we can
manage when it is called handle exceptions, units of work, etc.</p>
<p>It is worth remembering that handlers may be called after the target
handler (in essence you can designate an orthogonal handler as the sink
handler when configuring your pipeline). For this reason <strong>**all**</strong>
handlers should remember to call their successor, <strong>even **your**
target handler</strong>.</p>
<p>We now need to tell our pipeline to call this orthogonal handler before
our target handler. To do this we use attributes. The code we want to
write looks like this:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">GreetingCommandHandler</span> <span class="p">:</span> <span class="n">RequestHandler</span><span class="p">&lt;</span><span class="n">GreetingCommand</span><span class="p">&gt;</span>
<span class="p">{</span>
<span class="na">    [RequestLogging(step: 1, timing: HandlerTiming.Before)]</span>
    <span class="k">public</span> <span class="k">override</span> <span class="n">GreetingCommand</span> <span class="nf">Handle</span><span class="p">(</span><span class="n">GreetingCommand</span> <span class="n">command</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;Hello {0}&quot;</span><span class="p">,</span> <span class="n">command</span><span class="p">.</span><span class="n">Name</span><span class="p">);</span>
        <span class="k">return</span> <span class="k">base</span><span class="p">.</span><span class="n">Handle</span><span class="p">(</span><span class="n">command</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <strong>RequestLogging</strong> Attribute tells the Command Processor to insert a
Logging handler into the request handling pipeline before
(<strong>HandlerTiming.Before</strong>) we run the target handler. It tells the
Command Processor that we want it to be the first handler to run if we
have multiple orthogonal handlers i.e. attributes (<strong>step: 1</strong>).</p>
<p>We implement the <strong>RequestLoggingAttribute</strong> by creating our own
Attribute class, derived from <strong>RequestHandlerAttribute</strong>.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">RequestLoggingAttribute</span> <span class="p">:</span> <span class="n">RequestHandlerAttribute</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="nf">RequestLoggingAttribute</span><span class="p">(</span><span class="kt">int</span> <span class="n">step</span><span class="p">,</span> <span class="n">HandlerTiming</span> <span class="n">timing</span><span class="p">)</span>
        <span class="p">:</span> <span class="k">base</span><span class="p">(</span><span class="n">step</span><span class="p">,</span> <span class="n">timing</span><span class="p">)</span>
        <span class="p">{</span> <span class="p">}</span>

    <span class="k">public</span> <span class="k">override</span> <span class="kt">object</span><span class="p">[]</span> <span class="nf">InitializerParams</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="kt">object</span><span class="p">[]</span> <span class="p">{</span> <span class="n">Timing</span> <span class="p">};</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">override</span> <span class="n">Type</span> <span class="nf">GetHandlerType</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nf">typeof</span><span class="p">(</span><span class="n">RequestLoggingHandler</span><span class="p">&lt;&gt;);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The most important part of this implementation is the GetHandlerType()
method, where we return the type of our handler. At runtime the Command
Processor uses reflection to determine what attributes are on the target
handler and requests an instance of that type from the user-supplied
<strong>Handler Factory</strong>.</p>
<p>Your Handler Factory needs to respond to requests for instances of a
<strong>RequestHandler&lt;T&gt;</strong> specialized for a concrete type. For example, if
you create a <strong>RequestLoggingHandler&lt;TRequest&gt;</strong> we will ask you for a
<strong>RequestLoggingHandler&lt;MyCommand&gt;</strong> etc. Depending on your
implementation of HandlerFactory, you may need to register an
implementation for every concrete instance of your handler with your
underlying IoC container etc.</p>
<p>Note that as we rely on an user supplied implementation of
<strong>IAmAHandlerFactory</strong> to instantiate Handlers, you can have any
dependencies in the constructor of your handler that you can resolve at
runtime. In this case we pass in an ILog reference to actually log to.</p>
<p>You may wish to pass parameter from your Attribute to the handler.
Attributes can have constructor parameters or public members that you
can set when adding the Attribute to a target method. These can only be
compile time constants, see the documentation
<a class="reference external" href="https://msdn.microsoft.com/en-us/library/aa664615%28v=vs.71%29.aspx">here</a>.  // old link???
After the Command Processor calls your Handler Factory to create an
instance of your type it calls the
<strong>RequestHandler.InitializeFromAttributeParams</strong> method on that created
type and passes it the object array defined in the
<strong>RequestHandlerAttribute.InitializerParams</strong>. By this approach, you can
pass parameters to the handler, for example the Timing parameter is
passed to the handler above.</p>
<p>It is worth noting that you are limited when using Attributes to provide
constructor values that are compile time constants, you cannot pass
dynamic information. To put it another way you are limited to value set
at design time not at run time.</p>
<p>In fact, you can use this approach to pass any data to the handler on
initialization, not just attribute constructor or property values, but
you are constrained to what you can access from the context of the
Attribute at run time. it can be tempting to set retrieve global state
via the <a class="reference external" href="https://en.wikipedia.org/wiki/Service_locator_pattern">Service
Locator</a>
pattern at this point. Avoid that temptation as it creates coupling
between your Attribute and global state reducing modifiability.</p>
</div>
<div class="section" id="using-a-manual-approach">
<h1>Using a Manual Approach<a class="headerlink" href="#using-a-manual-approach" title="Permalink to this headline">¶</a></h1>
<p>Using an attribute based approach is not an approach favoured by
everyone. Some people prefer a more explicit approach to configuring the
pipeline.</p>
<p>This is possible, we just don’t provide any help out-of-the-box.
Although see this
<a class="reference external" href="https://github.com/BrighterCommand/Brighter/issues/4">issue</a> for a
placeholder to fix that.</p>
<p>The trick is to remember that any handler that derives from
<strong>IHandleRequests&lt;TRequest&gt;</strong> has a <strong>Successor</strong> and you can build a
chain by having the first handler call the second handler’s <strong>Handle()</strong>
method i.e. <strong>Successor.Handle()</strong>. You can derive from
<strong>RequestHandler&lt;T&gt;</strong> and call <strong>base.Handle()</strong> for this, even if you
don’t want to use the Attribute based pipelines.</p>
<p>In the SubscriberRegistry you just register the first Handler in your
pipeline. When we lookup the Handler for the Command in the
SubscriberRegistry we will call it’s Handle method. It can execute your
code, and then call it’s Successor (using the Russian Doll approach).</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">myCommandHandler</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MyCommandHandler</span><span class="p">();</span>
<span class="kt">var</span> <span class="n">myLoggingHandler</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MyLoggingHandler</span><span class="p">(</span><span class="n">log</span><span class="p">);</span>

<span class="n">myLoggingHandler</span><span class="p">.</span><span class="n">Successor</span> <span class="p">=</span> <span class="n">myCommandHandler</span><span class="p">;</span>

<span class="kt">var</span> <span class="n">subscriberRegistry</span> <span class="p">=</span> <span class="k">new</span> <span class="n">SubscriberRegistry</span><span class="p">();</span>
<span class="n">subscriberRegistry</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">MyCommand</span><span class="p">,</span> <span class="n">MyLoggingHandler</span><span class="p">&gt;();</span>
</pre></div>
</div>
<p>It is worth noting that as you control the HandlerFactory, you could
also register the sink handler, but when instantiating an instance of it
on request, build the pipeline of handlers yourself.</p>
<p>We think it is easier to use attributes, but there may be circumstances
where that approach does not work, and so this option is supported as
well.</p>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="UsingTheContextBag.html" class="btn btn-neutral float-right" title="Passing information between Handlers in the Pipeline" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="DispatchingARequest.html" class="btn btn-neutral" title="Dispatching Requests" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, Ian Cooper

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
    

  

  <script type="text/javascript" src="_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>