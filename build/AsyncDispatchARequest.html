

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Dispatching Requests Asynchronously &mdash; Paramore 7.0.0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="How to Implement an Asynchronous Request Handler" href="ImplementingAsyncHandler.html" />
    <link rel="prev" title="AWS SQS Configuration" href="AWSSQSConfiguration.html" /> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> Paramore
          

          
          </a>

          
            
            
              <div class="version">
                7.0.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="ImplementingAHandler.html">How to Implement a Request Handler</a></li>
<li class="toctree-l1"><a class="reference internal" href="DispatchingARequest.html">Dispatching Requests</a></li>
<li class="toctree-l1"><a class="reference internal" href="BuildingAPipeline.html">Building a Pipeline of Request Handlers</a></li>
<li class="toctree-l1"><a class="reference internal" href="BuildingAPipeline.html#the-pipes-and-filters-architectural-style">The Pipes and Filters Architectural Style</a></li>
<li class="toctree-l1"><a class="reference internal" href="BuildingAPipeline.html#the-russian-doll-model">The Russian Doll Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="BuildingAPipeline.html#implementing-a-pipeline">Implementing a Pipeline</a></li>
<li class="toctree-l1"><a class="reference internal" href="BuildingAPipeline.html#using-a-manual-approach">Using a Manual Approach</a></li>
<li class="toctree-l1"><a class="reference internal" href="UsingTheContextBag.html">Passing information between Handlers in the Pipeline</a></li>
<li class="toctree-l1"><a class="reference internal" href="PolicyRetryAndCircuitBreaker.html">Supporting Retry and Circuit Breaker</a></li>
<li class="toctree-l1"><a class="reference internal" href="PolicyRetryAndCircuitBreaker.html#using-brighter-s-usepolicy-attribute">Using Brighter’s UsePolicy Attribute</a></li>
<li class="toctree-l1"><a class="reference internal" href="PolicyRetryAndCircuitBreaker.html#timeout">Timeout</a></li>
<li class="toctree-l1"><a class="reference internal" href="PolicyFallback.html">Failure and Fallback</a></li>
<li class="toctree-l1"><a class="reference internal" href="EventSourcing.html">Event Sourcing</a></li>
<li class="toctree-l1"><a class="reference internal" href="EventSourcing.html#command-or-event-sourcing">Command or Event Sourcing</a></li>
<li class="toctree-l1"><a class="reference internal" href="EventSourcing.html#command-sourcing-in-brighter">Command Sourcing in Brighter</a></li>
<li class="toctree-l1"><a class="reference internal" href="BasicConfiguration.html">Basic Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="BasicConfiguration.html#what-you-need-to-provide">What you need to provide</a></li>
<li class="toctree-l1"><a class="reference internal" href="Logging.html">Supporting Logging</a></li>
<li class="toctree-l1"><a class="reference internal" href="ImplementingDistributedTaskQueue.html">Implementing a Distributed Task Queue</a></li>
<li class="toctree-l1"><a class="reference internal" href="ImplementingDistributedTaskQueue.html#brighter-s-task-queue-architecture">Brighter’s Task Queue Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="ImplementingDistributedTaskQueue.html#do-i-have-to-use-a-broker-what-about-msmq">Do I have to use a Broker, what about MSMQ?</a></li>
<li class="toctree-l1"><a class="reference internal" href="ImplementingDistributedTaskQueue.html#what-happens-when-the-consumer-receives-the-message">What happens when the consumer receives the message?</a></li>
<li class="toctree-l1"><a class="reference internal" href="ImplementingDistributedTaskQueue.html#what-does-this-look-like-in-code">What does this look like in code</a></li>
<li class="toctree-l1"><a class="reference internal" href="ImplementingDistributedTaskQueue.html#the-dispatcher">The Dispatcher</a></li>
<li class="toctree-l1"><a class="reference internal" href="ImplementingDistributedTaskQueue.html#configuration">Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="Routing.html">Routing</a></li>
<li class="toctree-l1"><a class="reference internal" href="DistributedTaskQueueConfiguration.html">Distributed Task Queue Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="DistributedTaskQueueConfiguration.html#configuring-the-dispatcher-in-code">Configuring the Dispatcher in Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="RabbitMQConfiguration.html">RabbitMQ Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="RunningUnderAWSSQSInfrastructure.html">Running Brighter under AWS SQS Infrastructure</a></li>
<li class="toctree-l1"><a class="reference internal" href="AWSSQSConfiguration.html">AWS SQS Configuration</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Dispatching Requests Asynchronously</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#usage">Usage</a></li>
<li class="toctree-l2"><a class="reference internal" href="#registering-a-handler">Registering a Handler</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pipelines-must-be-homogeneous">Pipelines Must be Homogeneous</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#dispatching-requests">Dispatching Requests</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#cancellation">Cancellation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#do-not-block-when-calling-async-methods">Do Not Block When Calling *Async Methods</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#understand-captured-contexts">Understand Captured Contexts</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#asynchronous-vs-work-queues">Asynchronous vs. Work Queues</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ImplementingAsyncHandler.html">How to Implement an Asynchronous Request Handler</a></li>
<li class="toctree-l1"><a class="reference internal" href="BuildingAnAsyncPipeline.html">Building a Pipeline of Async Request Handlers</a></li>
<li class="toctree-l1"><a class="reference internal" href="BuildingAnAsyncPipeline.html#implementing-a-pipeline">Implementing a Pipeline</a></li>
<li class="toctree-l1"><a class="reference internal" href="Monitoring.html">Monitoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="FeatureSwitches.html">Feature Switches</a></li>
<li class="toctree-l1"><a class="reference internal" href="faq.html">Frquently Asked Questions</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Paramore</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Dispatching Requests Asynchronously</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/AsyncDispatchARequest.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="dispatching-requests-asynchronously">
<h1>Dispatching Requests Asynchronously<a class="headerlink" href="#dispatching-requests-asynchronously" title="Permalink to this headline">¶</a></h1>
<p>Brighter supports an asynchronous <a class="reference external" href="https://brightercommand.github.io/Brighter/CommandsCommandDispatcherandProcessor.html">Command Dispatcher and Command
Processor</a>.   // Failing Link</p>
<p>Using an asynchronous approach to dispatch can be valuable when the work
done by a handler can be done concurrently with other work. Instead of
blocking on the call to <strong>Send</strong> or <strong>Publish</strong> the calling thread can
continue to do work, with a continuation executing once the operation
completes. See the MSDN article <a class="reference external" href="https://docs.microsoft.com/en-us/dotnet/csharp/async">Asynchronous Programming with Async and
Await</a></p>
<p>Brighter supports using the async…await pattern in .NET to allow your
code to avoid blocking. We provide asynchronous versions of the
<strong>Command Dispatcher</strong> methods i.e. <strong>CommandProcessor.SendAsync()</strong>,
<strong>CommandProcessor.PublishAsync()</strong>, and
<strong>CommandProcessor.PostAsync()</strong>.</p>
<div class="section" id="usage">
<h2>Usage<a class="headerlink" href="#usage" title="Permalink to this headline">¶</a></h2>
<p>In the following example code we register a handler, create a command
processor, and then use that command processor to send a command to the
handler asynchronously.</p>
<p>Note that this code is the same as the equivalent code for calling the
command processor synchronously - apart from the use of async
alternatives i.e. <strong>SubscriberRegistry.RegisterAsync()</strong> instead of
<strong>SubscriberRegistry.Register()</strong> and <strong>CommandProcessor.SendAsync()</strong>
instead of <strong>CommandProcessor.Send()</strong>.</p>
<p>Note also that we have a <strong>SimpleHandlerFactoryAsync</strong> as this factory
needs to return handlers that implement <strong>IHandleRequestsAsync</strong> not
<strong>IHandleRequests</strong>.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">private</span> <span class="k">static</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">MainAsync</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">registry</span> <span class="p">=</span> <span class="k">new</span> <span class="n">SubscriberRegistry</span><span class="p">();</span>
    <span class="n">registry</span><span class="p">.</span><span class="n">RegisterAsync</span><span class="p">&lt;</span><span class="n">GreetingCommand</span><span class="p">,</span> <span class="n">GreetingCommandRequestHandlerAsync</span><span class="p">&gt;();</span>

    <span class="kt">var</span> <span class="n">builder</span> <span class="p">=</span> <span class="n">CommandProcessorBuilder</span><span class="p">.</span><span class="n">With</span><span class="p">()</span>
    <span class="p">.</span><span class="n">Handlers</span><span class="p">(</span><span class="k">new</span> <span class="n">HandlerConfiguration</span><span class="p">(</span><span class="n">registry</span><span class="p">,</span> <span class="k">new</span> <span class="n">SimpleHandlerFactoryAsync</span><span class="p">()))</span>
    <span class="p">.</span><span class="n">DefaultPolicy</span><span class="p">()</span>
    <span class="p">.</span><span class="n">NoTaskQueues</span><span class="p">()</span>
    <span class="p">.</span><span class="n">RequestContextFactory</span><span class="p">(</span><span class="k">new</span> <span class="n">InMemoryRequestContextFactory</span><span class="p">());</span>

    <span class="kt">var</span> <span class="n">commandProcessor</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>

    <span class="k">await</span> <span class="n">commandProcessor</span><span class="p">.</span><span class="n">SendAsync</span><span class="p">(</span><span class="k">new</span> <span class="n">GreetingCommand</span><span class="p">(</span><span class="s">&quot;Ian&quot;</span><span class="p">));</span>

    <span class="n">Console</span><span class="p">.</span><span class="n">ReadLine</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note that line: <strong>Console.ReadLine()</strong> is a continuation. Control passes
back to the calling method after the await, and subsequent lines of code
run after that method returns.</p>
</div>
<div class="section" id="registering-a-handler">
<h2>Registering a Handler<a class="headerlink" href="#registering-a-handler" title="Permalink to this headline">¶</a></h2>
<p>In order for a <strong>Command Dispatcher</strong> to find a Handler for your
<strong>Command</strong> or <strong>Event</strong> you need to register the association between
that <strong>Command</strong> or <strong>Event</strong> and your Handler.</p>
<p>The <strong>Subscriber Registry</strong> is where you register your Handlers.</p>
<p>The <strong>SubscriberRegistry.RegisterAsync()</strong> expects a handler that
implements <strong>IHandleRequestsAsync</strong></p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="kt">var</span> <span class="n">registry</span> <span class="p">=</span> <span class="k">new</span> <span class="n">SubscriberRegistry</span><span class="p">();</span>
<span class="n">registry</span><span class="p">.</span><span class="n">RegisterAsync</span><span class="p">&lt;</span><span class="n">GreetingCommand</span><span class="p">,</span> <span class="n">GreetingCommandRequestHandlerAsync</span><span class="p">&gt;();</span>
</pre></div>
</div>
<div class="section" id="pipelines-must-be-homogeneous">
<h3>Pipelines Must be Homogeneous<a class="headerlink" href="#pipelines-must-be-homogeneous" title="Permalink to this headline">¶</a></h3>
<p>Brighter only supports pipelines that are solely
<strong>IHandleRequestsAsync</strong> or <strong>IHandleRequests</strong>.</p>
<p>This is due to expectation of the caller using an <strong>*Async</strong> method
that the code will execute asynchronously - allowing some handlers in
the chain to block would defy that expectations. The async…await
pattern is often described as ‘viral’ because it spreads up the chain of
callers to be effective. Brighter is no exception in this regard.</p>
</div>
</div>
<div class="section" id="dispatching-requests">
<h2>Dispatching Requests<a class="headerlink" href="#dispatching-requests" title="Permalink to this headline">¶</a></h2>
<p>Once you have registered your Handlers, you can dispatch requests to
them. To do that you simply use the <strong>CommandProcessor.SendAsync()</strong> (or
<strong>CommandProcessor.PublishAsync()</strong> or
<strong>CommandProcessor.PostAsync()</strong>) method passing in an instance of
your command.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">await</span> <span class="n">commandProcessor</span><span class="p">.</span><span class="n">SendAsync</span><span class="p">(</span><span class="k">new</span> <span class="n">GreetingCommand</span><span class="p">(</span><span class="s">&quot;Ian&quot;</span><span class="p">));</span>
</pre></div>
</div>
<div class="section" id="cancellation">
<h3>Cancellation<a class="headerlink" href="#cancellation" title="Permalink to this headline">¶</a></h3>
<p>Brighter supports the cancellation of asynchronous operations.</p>
<p>The asynchronous methods: <strong>SendAsync</strong>, <strong>PublishAsync</strong>, and
<strong>PostAsync</strong> all accept a <strong>CancellationToken</strong> and pass this token
down the pipeline. The parameter defaults to null where the call does
not intend to cancel.</p>
<p>The responsibility for checking for a cancellation request lies with the
individual handlers, which must determine what action to take if
cancellation had been signalled.</p>
<p>The ability of the <strong>*Async</strong> methods to take a cancellation token can
be particularly useful with ASP.NET AsyncTimeout see <a class="reference external" href="https://dotnetcodr.com/2013/01/04/timeout-exceptions-with-asyncawait-in-net4-5-mvc4-with-c/">here for
more.</a></p>
</div>
</div>
<div class="section" id="do-not-block-when-calling-async-methods">
<h2>Do Not Block When Calling *Async Methods<a class="headerlink" href="#do-not-block-when-calling-async-methods" title="Permalink to this headline">¶</a></h2>
<p>When calling an asynchronous method you should <strong>await</strong> that method.
Avoid using <strong>.Wait</strong> or <strong>.Result</strong> on the <strong>Task</strong> returned by the
method, as this turns it back into a blocking call, which is probably
not your intent and likely undermines the reason you wanted to use an
asynchronous approach in the first place. If you find yourself using
<strong>.Wait</strong> or <strong>.Result</strong> then consider whether you would be better using
a synchronous pipeline instead.</p>
<p>Therefore you should only call <strong>SendAsync</strong>, <strong>PublishAsync</strong>, or
<strong>PostAsync</strong> from a method that is itself async and supports await,
otherwise you will block, and there will be no value to having used an
async method.</p>
<p>In <a class="reference external" href="PortsAndAdapters.html">Ports &amp; Adapters Architecture</a> terms you      // failing link!!! replace it
should use an <strong>Adapter</strong> layer that supports async when calling the
<strong>Ports</strong> layer represented by your handlers.</p>
<p>This creates the question: at what point do we stop being async i.e. who
waits? This is normally a responsibility of your framework which has to
understand that it can use re-use thread to service other requests, thus
improving throughput and call back to your continuation when done.</p>
<p>For example ASP.NET Controllers <a class="reference external" href="https://www.asp.net/mvc/overview/performance/using-asynchronous-methods-in-aspnet-mvc-4">support
async</a>
can be used to call the <strong>*Async methods</strong> without blocking. This
allows ASP.NET to release a thread from the thread pool to service
another request whilst the asynchronous operation completes, allowing
greater throughput on the server.</p>
<div class="section" id="understand-captured-contexts">
<h3>Understand Captured Contexts<a class="headerlink" href="#understand-captured-contexts" title="Permalink to this headline">¶</a></h3>
<p>When an awaited method completes, what thread runs any completion code?
The answer depends on the SynchronizationContext which is ‘captured’ at
the point await is called. For ASP.NET or Windows Forms, WPF, or Metro
apps then the SynchronizationContext means that the thread that was
running at the point we yielded runs the continuation. Otherwise the
SynchronizationContext is null and the default Task Scheduler runs the
continuation.</p>
<p>Why does this matter? Because if you needed to access anything that is
thread local, being called back on the wrong thread means you will not
have access to those variables.</p>
<p>A Windows UI for example is single-threaded via a message pump and
interacting with the UI requires you to be on that thread. See <a class="reference external" href="https://blogs.msdn.com/b/pfxteam/archive/2012/01/20/10259049.aspx">this
article for
more.</a></p>
<p>When awaiting it is possible to configure how the continuation runs - on
the SyncronizationContext or using the Task Scheduler, overriding the
default behaviour, which is to capture the SynchronizationContext.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">await</span> <span class="nf">MethodAsync</span><span class="p">(</span><span class="k">value</span><span class="p">,</span> <span class="n">ct</span><span class="p">).</span><span class="n">ConfigureAwait</span><span class="p">(</span><span class="k">true</span><span class="p">);</span>
</pre></div>
</div>
<p>Library writers are encouraged to default to false i.e. use the Task
Scheduler instead of the SychronizationContext.</p>
<p>Brighter adopts this default, but recognizes it might not be what you
want if your handler needs to run in the context of the original thread.
As a result we let you pass in a parameter on the <strong>*Async</strong> calls to
change the behaviour throughout your pipeline.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">await</span> <span class="n">commandProcessor</span><span class="p">.</span><span class="n">SendAsync</span><span class="p">(</span><span class="k">new</span> <span class="n">GreetingCommand</span><span class="p">(</span><span class="s">&quot;Ian&quot;</span><span class="p">),</span> <span class="n">continueOnCapturedContext</span><span class="p">:</span> <span class="k">true</span><span class="p">);</span>
</pre></div>
</div>
<p>A handler exposes the parameter you supply to the call to <strong>SendAsync</strong>,
<strong>PublishAsync</strong>, or <strong>PostAsync</strong> via a property called
<strong>ContinueOnCapturedContext</strong>. That property is true if we want to use
the SynchronizationContext and not the Task Scheduler to run our
continuation.</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">await</span> <span class="k">base</span><span class="p">.</span><span class="n">HandleAsync</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="n">ct</span><span class="p">).</span><span class="n">ConfigureAwait</span><span class="p">(</span><span class="n">ContinueOnCapturedContext</span><span class="p">);</span>
</pre></div>
</div>
<p>We recommend explicitly using this parameter when awaiting within your
own handler, such as when calling the next handler in an async pipeline.</p>
</div>
</div>
<div class="section" id="asynchronous-vs-work-queues">
<h2>Asynchronous vs. Work Queues<a class="headerlink" href="#asynchronous-vs-work-queues" title="Permalink to this headline">¶</a></h2>
<p>One obvious question is: when should I use an asynchronous pipeline to
handle work and when should I use a work queue.</p>
<p>Using an asynchronous handler allows us to avoid blocking. This can
increase our throughput by allowing us to re-use threads to service new
requests. Using this approach, even a single-threaded application can
achieve high throughput, if it is not CPU-bound.</p>
<p>Using a work queue allows us to hand-off work to another process, to be
executed at some point in the future. This also allows us to improve
throughput by freeing up the thread to service new requests. We assume
that we can accept dealing with that work at some point in the future
i.e. we can be eventually consistent.</p>
<p>One disadvantage of a work queue is that our pattern - ack to callers,
and then do the work, can create additional complexity because we must
deal with notifying the user of completion, or errors. Because an async
operation simply has the caller wait, the programming model is simpler.
The trade-off here is that the client of our process is still using
resources awaiting for the request with the async operation. If the
operation takes time to complete the client may not know if the
operation failed and should be timed out, or is still running.</p>
<p>Where work is long-running there is a risk that the server faults, and
we lose the long-running work. A work queue provides reliability here,
through guaranteed delivery. The queue keeps the work until it is
successfully processed and acknowledged.</p>
<p>Our recommendation is to use the async pattern to improve throughput
where the framework supports async, such as ASP.NET WebAPI but to
continue to hand-off work that takes a long time to complete to a work
queue. You may choose to define your own thresholds but we recommend
that operations that take longer than 200ms to complete be handed-off.
We also recommend that operations that are CPU bound be handed-off as
they diminish the throughput of your application.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="ImplementingAsyncHandler.html" class="btn btn-neutral float-right" title="How to Implement an Asynchronous Request Handler" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="AWSSQSConfiguration.html" class="btn btn-neutral" title="AWS SQS Configuration" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, Ian Cooper

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
    

  

  <script type="text/javascript" src="_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>